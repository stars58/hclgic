#!/bin/bash -u
# This script is for checking database performance
#   beholder_db_performance.sh
#  Owner:   Shuzi Chen
#           Initial version: 04/11/2022
#
#  Revised: Bharat Harnwal
#           Revised version: 10/28/2022
# Steps:
#   1) Check blocking session
#   2) Check the last 24 hours blocking wait classes by sql queires
#   3) Redo generated by session > 1 GB (Only app users)
#   4) Check query CPU usage by session > 1 min
#   5) Check long running sessions > 30 seconds
#   6) Check long running query remaining time
#   7) Check wait classes (%) and number of session waiting (wait ratio)
 
 
workdir=$( echo $0|sed 's/\/beholder_db_performance.sh//' )
hostName=$( hostname )
host=$( echo ${hostName}|cut -d'.' -f 1 )
SQLPLUS="sqlplus -s / as sysdba"
dblog="/tmp/db_performance_validate.log"
 
# run a sqlplus function
connect_to_sql () {
SQL_OUTPUT=$( $ORACLE_HOME/bin/sqlplus -s / as sysdba<< OCI
set heading off
set feedback off
$1
exit
OCI
)
echo "$SQL_OUTPUT"| /bin/grep -v \^$
}
is_cdb=$( connect_to_sql "select cdb from v\$database;" )
 
function pass () {
 
        echo -e "\E[0;32mPASSED\E[0;39m"
 
}
 
 
function fail () {
 
        failed=true
        if [[ -z ${1} ]]; then
          echo -e "\E[0;31mFAILED\E[0;39m"
        else
          echo -e "\E[0;31mFAILED\E[0;39m - "${1}
        fi
}
 
function output () {
 
        pad=$(printf '%0.1s' "."{1..80})
        string=${1}
        printf '%s' "${1} "
        echo -en $(printf '%*.*s' 0 $(( 80 - ${#string})) "${pad}")" "
 
}
 
function color_header () {
         if [[ -n ${1} ]];then
           echo -e "\n\E[1;35m${1}\n\E[0;39m"
         fi
}
 
function warn () {
        if [[ -z ${1} ]]; then
          echo -e "\E[0;33mWARNING\E[0;39m"
        else
          echo -e "\E[0;33mWARNING\E[0;39m - "${1}
        fi
 
}
 
 
# Check lock session
check_lock_session() {
color_header "     1) Check blocking session..." |tee -a ${dblog}
lock_cnt=$( connect_to_sql "select count(*) from gv\$lock l1, gv\$lock l2 where l1.block =1 and l2.request > 0
                            and l1.id1=l2.id1 and l1.id2=l2.id2;" )
if [[ "${lock_cnt}" -gt 0 ]]; then
$SQLPLUS <<EOF | sed 's/^/\t/g'
set pages 1000
set lines 160
set echo off
set feedback off
select l1.inst_id instance_id,l1.sid session_id, ' is blocking ', l2.inst_id instance_id,l2.sid session_id
from gv\$lock l1, gv\$lock l2
where l1.block =1 and l2.request > 0
and l1.id1=l2.id1
and l1.id2=l2.id2;
exit;
EOF
else
echo -e "\tCurrently there is no blocking session.\n" |tee -a ${dblog}
fi
}
 
# Check the last 24 hours blocking wait classes by sql queries
check_24hours_lock_history() {
color_header "     2) Check the last 24 hours blocking wait classes by sql queries..." | tee -a ${dblog}
hours_lock_cnt=$( connect_to_sql "SELECT sum(count(*)) FROM V\$ACTIVE_SESSION_HISTORY a, v\$sql s, dba_users u
WHERE a.sql_id = s.sql_id
AND blocking_session IS NOT NULL
and a.user_id = u.user_id
AND a.user_id <> 0 -- exclude SYS user
AND a.sample_time >= SYSDATE - 1
group by a.sql_id, u.username,a.module,a.event;" )
if [[ "${hours_lock_cnt}" -gt 0 ]]; then
$SQLPLUS <<EOF | sed 's/^/\t/g'
set feedback off
set pages 1000
set lines 160
set echo off
col "SESSIONS WAITING" head "SESSIONS|WAITING"
col username format a20
col module format a30
col event format a35
SELECT a.sql_id,
u.username,
a.module,
a.event,
count(*) "SESSIONS WAITING"
FROM V\$ACTIVE_SESSION_HISTORY a, v\$sql s, dba_users u
WHERE a.sql_id = s.sql_id
AND blocking_session IS NOT NULL
and a.user_id = u.user_id
AND a.user_id <> 0 -- exclude SYS user
AND a.sample_time >= SYSDATE - 1
group by a.sql_id, u.username,a.module,a.event
order by a.sql_id, count(*) desc;
exit;
EOF
else
echo -e "\tCurrently there is no blocking history of session within 24 hours.\n" |tee -a ${dblog}
fi
}
#Check redo generated by sesion > 1GB
check_redo_gen() {
color_header "     3) Check redo generated by session > 1GB..." |tee -a ${dblog}
if [[ "${is_cdb}" == "YES" ]]; then
  redo_cnt=$( connect_to_sql "select count(*) from (
                             select c.name, se.username, round(sum(value)/1024/1024/1024, 2) value
                             from v\$sesstat s, v\$statname n, v\$session se, v\$containers c
                             where n.statistic# = s.statistic# and s.sid=se.sid and se.username is not null and s.con_id =c.con_id
                             and n.name = 'redo size' group by c.name, se.username ) where value > 1;" )
  redo_str="select name \"DB NAME\", username \"USERNAME\", value \"REDO GENERATED SIZE(GB)\" from (
select c.name, se.username, round(sum(value)/1024/1024/1024, 2) value
from v\$sesstat s, v\$statname n, v\$session se, v\$containers c
where n.statistic# = s.statistic# and s.sid=se.sid and se.username is not null and s.con_id =c.con_id
and n.name = 'redo size' group by c.name, se.username ) where value > 1 and rownum < 10
order by value desc;"
else
  redo_cnt=$( connect_to_sql "select count(*) from (select se.username, round(sum(value)/1024/1024/1024, 2) value from v\$sesstat s, v\$statname n, v\$session se where n.statistic# = s.statistic# and s.sid=se.sid and se.username is not null and n.name = 'redo size' group by se.username ) where value > 1;")
  redo_str="select username \"USERNAME\", value \"REDO GENERATED SIZE(GB)\" from (select se.username, round(sum(value)/1024/1024/1024, 2) value from v\$sesstat s, v\$statname n, v\$session se where n.statistic# = s.statistic# and s.sid=se.sid and se.username is not null and n.name = 'redo size' group by se.username ) where value > 1 and rownum < 10 order by value desc;"
fi
 
if [[ "${redo_cnt}" -gt 0 ]]; then
$SQLPLUS <<EOF |sed 's/^/\t/g' 
set feedback off
set pages 1000
set lines 200
set echo off
col "DB NAME" format a30
col "USERNAME" format a30
col "REDO GENERATED SIZE(GB)" for 999999999999
${redo_str}
exit;
EOF
else
  echo -e "\tCurrently there is no app session generating redo > 1GB.\n" |tee -a ${dblog}
fi
}
# Check CPU used by session > 1 min
check_cpu_used_session() {
color_header "     4) Check CPU used by session > 1 min..." |tee -a ${dblog}
cpu_use_cnt=$( connect_to_sql " select count(*)  FROM v\$sesstat s,v\$statname t, v\$session n
                         WHERE s.statistic# = t.statistic# and sql_id is not null
                         AND n.sid = s.sid and n.username is not null and n.username not in ('SYS', 'SYSTEM')
                         AND t.name='CPU used by this session' and n.status='ACTIVE' and round((s.value/100)/60,2) > 1 ;")
if [[ "${cpu_use_cnt}" -gt 0 ]]; then
$SQLPLUS <<EOF | sed 's/^/\t/g'
set pages 1000
set lines 200
set feedback off
set echo off
col username format a30
spool ${dblog} append
SELECT n.username, s.sid, sql_id, round((s.value/100)/60,2) cpu_usage_mins  FROM v\$sesstat s,v\$statname t, v\$session n
WHERE s.statistic# = t.statistic# and sql_id is not null
AND n.sid = s.sid and n.username is not null and n.username not in ('SYS', 'SYSTEM')
AND t.name='CPU used by this session' and n.status='ACTIVE' and round((s.value/100)/60,2) > 1 and rownum < 10
ORDER BY s.value desc;
exit;
EOF
else
echo -e "\tCurrently there is no CPU usage by session > 1 min.\n" |tee -a ${dblog}
fi
}
#Check long running sessions > 30 seconds
check_long_running_sessions() {
color_header "     5) Check long running sessions > 30 seconds..." |tee -a ${dblog}
long_session_cnt=$( connect_to_sql "select count(*) from (
                       SELECT inst_id,sid,status,username,sql_id, MODULE, program, ROUND(elapsed_time/1000000) AS ElapsedTimeSeconds
                       FROM gv\$sql_monitor where  module not like '%emagent%'
                       ORDER BY ROUND(elapsed_time/1000000) desc
                       ) where ElapsedTimeSeconds > 30;" )
if [[ "${long_session_cnt}" -gt 0 ]]; then
$SQLPLUS <<EOF |sed 's/^/\t/g'
set lines 200 pages 9999 feedback off
col inst_id head "INST|ID" for 9999
column sid format 999999
column status format a20
column username format a10
column module format a30
col ElapsedSec head "ELAPSED|SECONDS" for 9999999
col program for a30
SELECT * FROM
(SELECT inst_id,sid,status,username,sql_id, MODULE, PROGRAM, ROUND(elapsed_time/1000000) AS ElapsedSec
FROM gv\$sql_monitor where  module not like '%emagent%'
ORDER BY ROUND(elapsed_time/1000000) desc
) where rownum < 10 and ElapsedSec > 30;
EOF
else
  echo -e "\tCurrently there is no long running session > 30 seconds.\n" |tee -a ${dblog}
fi
}
 
#Check long running query remaining time
check_long_query_remaininng() {
color_header "     6) Check long running query remaining time..." |tee -a ${dblog}
long_query_cnt=$( connect_to_sql "select count(*) from gv\$session_longops where TIME_REMAINING>0 order by TIME_REMAINING;")
if [[ "${long_query_cnt}" -gt 0 ]]; then
$SQLPLUS <<EOF |sed 's/^/\t/g'
set lines 160
col TARGET for a40
col SQL_ID for a20
set feedback off
select INST_ID,SID,SQL_ID,TARGET||OPNAME TARGET, TIME_REMAINING/60 Mins_Remaining,ELAPSED_SECONDS from gv\$session_longops where TIME_REMAINING>0
order by TIME_REMAINING;
EOF
else
  echo -e "\tCurrently there is no long running query.\n" |tee -a ${dblog}
fi;
}
#Check wait classes (%) and number of session waiting
check_wait_classes_session() {
color_header "     7) Check wait classes and number of session waiting in each wait class..." |tee -a ${dblog}
wait_cnt=$( connect_to_sql "select count(*) from
(select round(sm.value/pm.value) || ' (%)' as waittime from v\$sysmetric sm, v\$parameter pm where sm.group_id=2 and metric_id=2123 and pm.name='cpu_count') a,
(select sumg || un sessions_waiting from (select sumg,un from (select cnt,',' || substr(sys_connect_by_path(fullvalue, '#'),2) as un,sumg
from (SELECT '[ ' || wait_class || ' - '|| event || ' - ' || groupcnt || ' ]' as fullvalue, row_number () over (order by groupcnt desc) rn, count(*) over () cnt, sum(groupcnt) over () sumg
from (select wait_class, event, count(*) as groupcnt FROM V\$SESSION_WAIT WHERE (upper(event) not like '%IDLE%' and event not like 'SQL*Net%' and event not like 'PX%Reply%'
and event not like 'Streams AQ%' and event not like 'Backup: MML%') AND event not in ('dispatcher listen timer','ges cached resource cleanup','ges lmd and pmon to attach',
'ges pmon to exit','index (re)build online cleanup','pmon dblkr tst event','PX Deq: Test for credit','queue slave messages','rdbms ipc message block','timer in sksawat','OJVM: Generic')
AND event not in (select name from v\$event_name where WAIT_CLASS='Idle')
GROUP BY wait_class, event ORDER BY count(*) desc)) where rn = cnt start with rn = 1 connect by rn = prior rn +1 union select 0, null, 0 from dual) order by cnt desc) where rownum=1) b;")
if [[ "${wait_cnt}" -gt 0 ]]; then
$SQLPLUS <<EOF  |sed 's/,\[/\n\nSESSION(s) INFO:\n----------------\n\n\[/g' | sed 's/\]#\[/\]\n\[/g' |sed 's/^/\t/g' |sed 's/-------------------------------------------------------------------//g' |sed 's/#//g'
set pages 500
set lines 200
set feedback off
col "Wait % - Number of Sessions" for a150
select a.waittime || ' - ' || b.sessions_waiting as "Wait % - Number of Sessions" from
(select round(sm.value/pm.value) || ' (%)' as waittime from v\$sysmetric sm, v\$parameter pm where sm.group_id=2 and metric_id=2123 and pm.name='cpu_count') a,
(select sumg || un sessions_waiting from (select sumg,un from (select cnt,',' || substr(sys_connect_by_path(fullvalue, '#'),2) as un,sumg
from (SELECT '[ ' || wait_class || ' - '|| event || ' - ' || groupcnt || ' ]' as fullvalue, row_number () over (order by groupcnt desc) rn, count(*) over () cnt, sum(groupcnt) over () sumg
from (select wait_class, event, count(*) as groupcnt FROM V\$SESSION_WAIT WHERE (upper(event) not like '%IDLE%' and event not like 'SQL*Net%' and event not like 'PX%Reply%'
and event not like 'Streams AQ%' and event not like 'Backup: MML%') AND event not in ('dispatcher listen timer','ges cached resource cleanup','ges lmd and pmon to attach',
'ges pmon to exit','index (re)build online cleanup','pmon dblkr tst event','PX Deq: Test for credit','queue slave messages','rdbms ipc message block','timer in sksawat','OJVM: Generic')
AND event not in (select name from v\$event_name where WAIT_CLASS='Idle')
GROUP BY wait_class, event ORDER BY count(*) desc)) where rn = cnt start with rn = 1 connect by rn = prior rn +1 union select 0, null, 0 from dual) order by cnt desc) where rownum=1) b;
EOF
else
  echo -e "\tCurrently there is no waiting.\n" |tee -a ${dblog}
fi;
}
# Verify it's logged in as oracle
loguser=$( whoami )
if [[ "${loguser}" != "oracle" ]]; then
 echo -e "     You have to login as oracle to run this script."
 exit 0
fi
color_header "\n     Checking any database performance issues...\n"
date_today=$(printf '%-123s' "$(date)")
host_name_desc=$(printf '%-139s' "Host Name: \E[0;33m${host}\E[0;39m")
num_sid_desc_e1=$(printf '%-123s' "Error: No instance is up running on ${host} but there is instance(s) registered in /etc/oratab.")
num_sid_desc_e2=$(printf '%-123s' "No instance created on ${host}.")
num_sid_desc_e3=$(printf '%-122s' " instance(s) found up and running on ${host}")
box_filler="     |                                                                                                                            |"
echo -e "     ------------------------------------------------------------------------------------------------------------------------------"
echo -e "${box_filler}"
echo -e "     | \E[0;33m${date_today}\E[0;39m|" | tee  $dblog
echo -e "${box_filler}"
echo -e "     | ${host_name_desc}|" | tee -a $dblog
echo -e "${box_filler}"
 
SID_CNT=$( ps -ef | grep ora_pmon | grep -v grep |grep -v ASM |grep -v ORCL | cut -d'_' -f3 | grep -v ^+ | wc -l )
if [[ "${SID_CNT}" -lt 1 ]]; then
# Check any instance in /etc/oratab file
num_sid=$( grep -v \^# /etc/oratab|grep -i /app/oracle|grep -v ASM|grep -v ORCL|cut -d ':' -f 2|wc -l)
 if [[ "$num_sid" -gt 0 ]]; then
  echo -e "     | ${num_sid_desc_e1}|" | tee -a $dblog
  echo -e "${box_filler}"
  echo -e "     ------------------------------------------------------------------------------------------------------------------------------"
  color_header "     Exiting performance checks..."
  exit 0
 else
  echo -e "     | ${num_sid_desc_e2}|" | tee -a $dblog
  echo -e "${box_filler}"
  echo -e "     ------------------------------------------------------------------------------------------------------------------------------"
  color_header "     Exiting performance checks..."
  exit 0
 fi
else
  echo -e "     | \E[0;33m${SID_CNT}\E[0;39m${num_sid_desc_e3}|" | tee -a $dblog
for dbhome in $( grep -v \^# /etc/oratab|grep -i /oracle|grep -v ASM|grep -v ORCL|cut -d ':' -f 2 ); do
 break
done
fi
echo -e "${box_filler}"
echo -e "     ------------------------------------------------------------------------------------------------------------------------------"
export ORACLE_HOME=${dbhome}
export PATH=$ORACLE_HOME/bin:$PATH
export LD_LIBRARY_PATH=$ORACLE_HOME/lib
 
for dbsid in $( ps -ef | grep "ora_pmon_" | grep -v grep |grep -v ASM |grep -v ORCL | cut -d'_' -f3 | grep -v ^+ ) ; do
export ORACLE_SID=${dbsid};
db_unique=$( connect_to_sql "select value from v\$parameter where name='db_unique_name';" )
color_header "\n     =================================================================================================="
echo -e "                            \E[1;35mBegin performance checks for : \E[0;33m${db_unique}\E[0;39m"
color_header "     ==================================================================================================\n"
echo -e "     Database Instance Name: \E[0;33m${dbsid}\E[0;39m\n" | tee -a $dblog
# Check database role if it's standby exit
db_role=$( connect_to_sql "select count(*) from v\$database where database_role = 'PHYSICAL STANDBY' or open_mode = 'MOUNTED' or open_mode = 'READ ONLY WITH APPLY';" )
if [[ "${db_role}" -eq 1 ]]; then
 echo -e "     The database ${db_unique} is a \E[0;33mstandby database\E[0;39m. Exiting performance checks...\n"| tee -a ${dblog}
 continue
fi
# Check blocking session
check_lock_session
#Check the last 24 hours wait classes by sql queires
check_24hours_lock_history
#Check redo generated by session
check_redo_gen
# Check CPU used by Session > 1 min
check_cpu_used_session
#Check long running sessions > 30 seconds
check_long_running_sessions
#Check long running query remaining time
check_long_query_remaininng
#Check wait classes (%) and number of session waiting
check_wait_classes_session
done
stty sane